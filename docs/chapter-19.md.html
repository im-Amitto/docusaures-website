<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Configuring Queue Adapters for Background Processing · Learn Ruby on Rails</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;As our application size grows,&lt;/p&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Configuring Queue Adapters for Background Processing · Learn Ruby on Rails"/><meta property="og:type" content="website"/><meta property="og:url" content="https://im-amitto.github.io/https://im-amitto.github.io/docusaures-website/"/><meta property="og:description" content="&lt;p&gt;As our application size grows,&lt;/p&gt;
"/><meta property="og:image" content="https://im-amitto.github.io/https://im-amitto.github.io/docusaures-website/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://im-amitto.github.io/https://im-amitto.github.io/docusaures-website/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="https://im-amitto.github.io/docusaures-website/img/logo.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="./../css/prism.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="./../js/prism.js"></script><script type="text/javascript" src="./../js/custom.js"></script><link rel="stylesheet" href="https://im-amitto.github.io/docusaures-website/css/main.css"/><script src="https://im-amitto.github.io/docusaures-website/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="https://im-amitto.github.io/docusaures-website/"><img class="logo" src="https://im-amitto.github.io/docusaures-website/img/logo.png" alt="Learn Ruby on Rails"/><h2 class="headerTitleWithLogo">Learn Ruby on Rails</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"></ul></nav></div></header></div></div><div class="navPusher singleRowMobileNav"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>book</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">book</h3><ul class=""><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/">Introduction</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-0.md">Installing Ruby on Rails and VSCode</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-1.md">Building a new Rails application</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-2.md">Getting started with Ruby on Rails</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-3.md">Task controller</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-4.md">Adding tasks through browser</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-5.md">Show a task</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-6.md">Update the task</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-7.md">Delete the task</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-8.md">Introduction to Validation</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-9.md">Active Record Callbacks and Object Life Cycle</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-10.md">Introducing User model</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-11.md">Authentication</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-12.md">Introduction to Authorization</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-13.md">State Management via Ajax</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-14.md">Adding comments to Tasks</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-15.md">Attaching files</a></li><li class="navListItem"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-16.md">Introduction to Testing and Writing Unit Tests</a></li><li class="navListItem navListItemActive"><a class="navItem" href="https://im-amitto.github.io/docusaures-website/docs/chapter-19.md">Configuring Queue Adapters for Background Processing</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Configuring Queue Adapters for Background Processing</h1></header><article><div><span><p>As our application size grows,
it becomes important to offload some computing/processing
to run in the background so that the end user's
experience in terms of performance of the app doesn't take a hit.
In our next chapter, we will be sending notifications
to users when a task is assigned to them.
Time of email receipts depends on multiple factors like
in-app mail server, smtp server, email client etc.
and we cannot be blocked on these in order to provide
any feedback to the user after he/she assigns a task to someone.
Hence the process of sending emails will be carried out asynchronously.</p>
<p>In this chapter we will emphasize
on configuring and understanding the necessary settings
that are required to perform background processing.</p>
<p>Rails provides a framework known as <strong><em>Active Job</em></strong>
that helps us declare jobs and making them run on a
variety of queueing backgrounds.</p>
<h2><a class="anchor" aria-hidden="true" id="choosing-a-backend-adapter"></a><a href="#choosing-a-backend-adapter" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Choosing a backend adapter</h2>
<p>Active Job has a built-in support for
multiple queueing backends.
Some of the prominent queueing backends
are <code>Sidekiq</code>, <code>Resque</code>, <code>Delayed Job</code> etc.
Getting into details of each queueing adapter
is not within the scope of this book,
but you can always visit <a href="https://edgeapi.rubyonrails.org/classes/ActiveJob/QueueAdapters.html">this page</a>
of Rails guides to know about
all the queueing adapters supported by Rails by default.</p>
<p>We'll choose <code>Sidekiq</code> as queueing adapter for our app.
Sidekiq uses redis to store all the operational data.
So let's setup redis on the development machine.
If you're using Mac OS, then redis will be installed
by following command.</p>
<pre><code class="hljs css language-beam.assembly"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>redis
</code></pre>
<p>Once it's done, start redis server</p>
<pre><code class="hljs css language-beam.assembly"><span class="hljs-keyword">brew </span>services start redis
</code></pre>
<p>Now redis should be up an running.</p>
<p>Go to your Gemfile and add the following line to install <code>sidekiq</code> gem.</p>
<pre><code class="hljs css language-ruby">gem <span class="hljs-string">"sidekiq"</span>
</code></pre>
<p>Run <code>bundle install</code> so that the gem gets installed and your apk is bundled with it.</p>
<p>Now open <code>config/application.rb</code> file.
You should find a block of code where all the configurations are set.
Add the following line in that block</p>
<pre><code class="hljs css language-ruby">config.active_job.queue_adapter = <span class="hljs-symbol">:sidekiq</span>
</code></pre>
<p>You're all set!
Now restart your Rails server and in an other terminal window/tab
run the following command to start sidekiq.</p>
<pre><code class="hljs css language-bash">$ sidekiq
</code></pre>
<p>You'll notice that sidekiq process is running.
We'll refer this window as 'sidekiq window' whenever required.</p>
<h2><a class="anchor" aria-hidden="true" id="creating-a-job"></a><a href="#creating-a-job" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating a Job</h2>
<p>Run the following command on your terminal</p>
<pre><code class="hljs css language-bash">$ rails g job task_logger

create    <span class="hljs-built_in">test</span>/<span class="hljs-built_in">jobs</span>/task_logger_job_test.rb
create  app/<span class="hljs-built_in">jobs</span>/task_logger_job.rb

</code></pre>
<p>You'll notice that it creates two files <code>task_logger_job.rb</code> inside
<code>app/jobs</code> directory and its corresponding test file <code>task_logger_job_test.rb</code>
inside <code>test/jobs</code> directory.</p>
<p>The job file should look like this</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskLoggerJob</span> &lt; ApplicationJob</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p><code>ApplicationJob</code>, just is an abstract class where
we can define configurations for all the jobs that are defined
in our app. It inherits <code>ActiveJob::Base</code>.
In short, is analogous to <code>ApplicationRecord</code> that we have in case of models.</p>
<p><code>ActiveJob</code> internally invokes a method named <code>perform</code>.
So this method is responsible for executing
the entire business logic of the job.
Let's add <code>perform</code> method inside our <code>TaskLoggerJob</code> class.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskLoggerJob</span> &lt; ApplicationJob</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">perform</span></span>
    puts <span class="hljs-string">"TaskLoggerJob is performed"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>There you go! You've just defined a new job.</p>
<h2><a class="anchor" aria-hidden="true" id="executing-the-job"></a><a href="#executing-the-job" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Executing the Job</h2>
<p>Open your Rails console using <code>rails c</code>.
Now as you'd expect we can execute the <code>perform</code>
method that we've defined inside <code>TaskLoggerJob</code>
just like any other instance method of a class.
So let's see if that works.</p>
<pre><code class="hljs css language-ruby">TaskLoggerJob.new.perform
&gt; <span class="hljs-string">"TaskLoggerJob is performed"</span>
</code></pre>
<p>Great this works. But you might wonder how this <code>job</code>
is different from any other Ruby class.
The answer is that this class provides
an ability to enqueue this job to the backend queue.
Now in your Rails console, run the following</p>
<pre><code class="hljs css language-ruby">TaskLoggerJob.perform_later
&gt; Enqueued TaskLoggerJob
</code></pre>
<p>Notice the output here.
Instead of printing the message from <code>perform</code> method of the job,
it shows that the job is enqueued.
Now go to the sidekiq window where sidekiq is running.
You should observe that this job had run there and
the message <code>&quot;TaskLoggerJob is performed&quot;</code> is printed there.</p>
<p>Let's see what has happened here. We've called a method <code>perform_later</code>,
which is a class method available on every child class of <code>ActiveJob::Base</code>.
It internally instantiates the job instance and enqueues the job to the configured backend queue,
which in our case is sidekiq.
Once enqueued, sidekiq picks it upon availability and executes the perform method.
This is how we are able to run the jobs asynchronously using <code>perform_later</code> method.</p>
<p>We can also define when we want to run the job by using <code>set</code> option</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># By providing `wait_until` option, we are asking to not perform the job before the end of the day.</span>
TaskLoggerJob.set(<span class="hljs-symbol">wait_until:</span> Date.today.end_of_day).perform_later
</code></pre>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># By providing `wait` option we are here asking to perform after 1 minute.</span>
TaskLoggerJob.set(<span class="hljs-symbol">wait:</span> <span class="hljs-number">1</span>.minute).perform_later
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="active-job-callbacks"></a><a href="#active-job-callbacks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Active Job callbacks</h2>
<p>There could be cases when you might want to execute
the <code>perform</code> method synchronously too.
An other way of doing so is calling <code>perform_now</code> method on the job's class.</p>
<pre><code class="hljs css language-ruby">TaskLoggerJob.perform_now
<span class="hljs-string">"TaskLoggerJob is performed"</span>
</code></pre>
<p>Is there any difference between behaviours of <code>perform</code> and <code>perform_now</code>?
The answer is yes. The method <code>perform_now</code> is wrapped by the Active Job callbacks.
Similar to controllers and models, we can define the following callbacks inside
our jobs</p>
<pre><code class="hljs css language-msg"><span class="hljs-keyword">before_enqueue
</span><span class="hljs-symbol">around_enqueue</span>
<span class="hljs-symbol">after_enqueue</span>
<span class="hljs-keyword">before_perform
</span><span class="hljs-symbol">around_perform</span>
<span class="hljs-symbol">after_perform</span>
</code></pre>
<p>Let's add a <code>before_perform</code> and <code>after_perform</code> in our <code>TaskLoggerJob</code> class as follows.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskLoggerJob</span> &lt; ApplicationJob</span>
  <span class="hljs-comment"># ... existing code</span>
  before_perform <span class="hljs-symbol">:print_before_perform_message</span>
  after_perform <span class="hljs-symbol">:print_after_perform_message</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_before_perform_message</span></span>
    puts <span class="hljs-string">"Printing from inside before_perform callback"</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_after_perform_message</span></span>
    puts <span class="hljs-string">"Printing from inside after_perform callback"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Now reload Rails console and compare results between <code>perform</code> and <code>perform_now</code></p>
<pre><code class="hljs css language-ruby">TaskLoggerJob.perform
<span class="hljs-string">"TaskLoggerJob is performed"</span>


TaskLoggerJob.perform_now
<span class="hljs-string">"Printing from inside before_perform callback"</span>
<span class="hljs-string">"TaskLoggerJob is performed"</span>
<span class="hljs-string">"Printing from inside after_perform callback"</span>
</code></pre>
<p>If <code>perform_later</code> was instead of <code>perform_now</code>, all these messages would've got
printed in the sidekiq window instead of on Rails console as execution
will happen asynchronously.</p>
<p>The behaviour however will be different in case of <code>before_enqueue</code> and <code>after_enqueue</code> callbacks.
Since <code>perform_now</code> is run synchronously and there is no enqueueing of job,
defining these callbacks will have no effect when <code>perform_now</code> is used.</p>
<p>Let's verify this behaviour. Inside <code>TaskLoggerJob</code>, remove all existing callbacks
and add the following code</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskLoggerJob</span> &lt; ApplicationJob</span>
  before_enqueue <span class="hljs-symbol">:print_before_enqueue_message</span>
  after_enqueue <span class="hljs-symbol">:print_after_enqueue_message</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">perform</span></span>
    puts <span class="hljs-string">"TaskLoggerJob is performed"</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_before_enqueue_message</span></span>
    puts <span class="hljs-string">"Printing from inside before_enqueue callback"</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_after_enqueue_message</span></span>
      puts <span class="hljs-string">"Printing from inside after_enqueue callback"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Run the following on Rails console</p>
<pre><code class="hljs css language-ruby">TaskLoggerJob.perform_now
<span class="hljs-string">"TaskLoggerJob is performed"</span>


TaskLoggerJob.perform_later
<span class="hljs-string">"Printing from inside before_perform callback"</span>
</code></pre>
<p>You'll notice that the <code>before_enqueue</code> message has got printed only in case when <code>peform_later</code> was called.</p>
<h2><a class="anchor" aria-hidden="true" id="using-job-to-log-ip-address"></a><a href="#using-job-to-log-ip-address" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using job to log ip address</h2>
<p>Now let's use our <code>TaskLoggerJob</code> to actually log something.
Let's log the details of the task after the task had got created.
Add a <code>after_create</code> inside <code>app/models/task.rb</code> to</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> &lt; ApplicationRecord</span>
  after_create <span class="hljs-symbol">:log_task_details</span>

  <span class="hljs-comment"># Existing code ...</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log_task_details</span></span>
    TaskLoggerJob.perform_later(<span class="hljs-keyword">self</span>)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Notice that we have passed an argument to <code>perform_later</code> method.
The method <code>perform</code>, that we manually define inside the job can
take any number and any type of argument. In the above case,
we are considering a task record as an argument to <code>perform</code> action.</p>
<p>So let's clear all the actions that we have added in <code>TaskLoggerJob</code>
and define <code>perform</code> action as follows</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskLoggerJob</span> &lt; ApplicationJob</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">perform</span><span class="hljs-params">(task)</span></span>
    puts <span class="hljs-string">"Created a task with following attributes :: <span class="hljs-subst">#{task.attributes}</span>"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Now create a task in the browser and
notice that the log is printed in the sidekiq window
printing all the attributes of the newly created task.</p>
<p>Let's make use of the queue adapters that we've defined
and send email notifications in our next chapter.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="https://im-amitto.github.io/docusaures-website/docs/chapter-16.md"><span class="arrow-prev">← </span><span>Introduction to Testing and Writing Unit Tests</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#choosing-a-backend-adapter">Choosing a backend adapter</a></li><li><a href="#creating-a-job">Creating a Job</a></li><li><a href="#executing-the-job">Executing the Job</a></li><li><a href="#active-job-callbacks">Active Job callbacks</a></li><li><a href="#using-job-to-log-ip-address">Using job to log ip address</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2019 BigBinary</section></footer></div></body></html>